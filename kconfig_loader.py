"""
Kconfig Loader for Bloat Axis GEPA.

Loads .config files generated by menuconfig and converts them into
GEPAConfig dataclass for use by the evolution loop.
"""

from pathlib import Path
from typing import Dict, List, Optional

try:
    from .config import GEPAConfig
except ImportError:
    from config import GEPAConfig


class KconfigLoader:
    """Loads .config files and converts to GEPAConfig."""
    
    @staticmethod
    def load_config(config_path: str) -> GEPAConfig:
        """
        Load configuration from a .config file.
        
        Args:
            config_path: Path to .config file
            
        Returns:
            GEPAConfig object
        """
        config_path = Path(config_path)
        if not config_path.exists():
            raise FileNotFoundError(f"Config file not found: {config_path}")
        
        # Parse the .config file
        values = KconfigLoader._parse_config_file(config_path)
        
        # Build configuration object
        config = KconfigLoader._build_config(values)
        
        return config
    
    @staticmethod
    def _parse_config_file(config_path: Path) -> Dict[str, str]:
        """Parse a .config file into key-value pairs."""
        values = {}
        
        with open(config_path, 'r', encoding='utf-8') as f:
            for line in f:
                line = line.strip()
                
                # Skip comments and empty lines
                if not line or line.startswith('#'):
                    continue
                
                # Parse CONFIG_KEY=value
                if '=' in line:
                    key, value = line.split('=', 1)
                    key = key.strip()
                    value = value.strip()
                    
                    # Remove CONFIG_ prefix
                    if key.startswith('CONFIG_'):
                        key = key[7:]
                    
                    # Remove quotes from strings
                    if value.startswith('"') and value.endswith('"'):
                        value = value[1:-1]
                    
                    values[key] = value
        
        return values
    
    @staticmethod
    def _build_config(values: Dict[str, str]) -> GEPAConfig:
        """Build GEPAConfig from parsed values."""
        
        # Data paths
        dataset_path = values.get('GEPA_DATASET_PATH', '')
        pdf_dir = values.get('GEPA_PDF_DIR', '')
        output_dir = values.get('GEPA_OUTPUT_DIR', 'output')
        
        # Initial logs (optional)
        initial_logs_dir = None
        if values.get('GEPA_USE_INITIAL_LOGS', 'n') == 'y':
            initial_logs_dir = values.get('GEPA_INITIAL_LOGS_DIR', '')
        
        # Budget and sampling
        budget = int(values.get('GEPA_BUDGET', '100'))
        budget_discover = int(values.get('GEPA_BUDGET_DISCOVER', '5'))
        minibatch_size = int(values.get('GEPA_MINIBATCH_SIZE', '3'))
        n_pareto = int(values.get('GEPA_N_PARETO', '20'))
        k_diagnose = int(values.get('GEPA_K_DIAGNOSE', '3'))
        
        # Optimization weights (stored as x100 integers)
        lambda_ = int(values.get('GEPA_LAMBDA', '60')) / 100.0
        tau = int(values.get('GEPA_TAU', '70')) / 100.0
        correctness_tolerance = int(values.get('GEPA_CORRECTNESS_TOLERANCE', '10')) / 100.0
        
        # Logit processor defaults
        default_penalty = int(values.get('GEPA_DEFAULT_PENALTY', '200')) / 100.0
        min_new_tokens = int(values.get('GEPA_MIN_NEW_TOKENS', '48'))
        
        # Model configuration
        reflection_model = values.get('GEPA_REFLECTION_MODEL', 'gpt-4o')
        local_model = values.get('GEPA_LOCAL_MODEL', 'meta-llama/Llama-3.1-8B-Instruct')
        sglang_base_url = values.get('GEPA_SGLANG_BASE_URL', 'http://localhost:8000')
        
        # Protocol settings
        max_rounds = int(values.get('GEPA_MAX_ROUNDS', '5'))
        chunk_size = int(values.get('GEPA_CHUNK_SIZE', '3000'))
        
        # Build config
        config = GEPAConfig(
            dataset_path=dataset_path,
            pdf_dir=pdf_dir,
            output_dir=output_dir,
            budget=budget,
            budget_discover=budget_discover,
            minibatch_size=minibatch_size,
            n_pareto=n_pareto,
            k_diagnose=k_diagnose,
            lambda_=lambda_,
            tau=tau,
            default_penalty=default_penalty,
            min_new_tokens=min_new_tokens,
            reflection_model=reflection_model,
            local_model=local_model,
            sglang_base_url=sglang_base_url,
            max_rounds=max_rounds,
            chunk_size=chunk_size,
            correctness_tolerance=correctness_tolerance,
        )
        
        # Store initial_logs_dir as extra attribute
        config.initial_logs_dir = initial_logs_dir
        
        return config
    
    @staticmethod
    def validate_config(config: GEPAConfig) -> List[str]:
        """
        Validate configuration.
        
        Args:
            config: GEPAConfig to validate
            
        Returns:
            List of error messages (empty if valid)
        """
        errors = []
        
        if not config.dataset_path:
            errors.append("Dataset path is required (GEPA_DATASET_PATH)")
        elif not Path(config.dataset_path).exists():
            errors.append(f"Dataset path does not exist: {config.dataset_path}")
        
        if not config.pdf_dir:
            errors.append("PDF directory is required (GEPA_PDF_DIR)")
        elif not Path(config.pdf_dir).exists():
            errors.append(f"PDF directory does not exist: {config.pdf_dir}")
        
        if config.budget < config.budget_discover:
            errors.append("Total budget must be >= discovery budget")
        
        if config.lambda_ < 0 or config.lambda_ > 1:
            errors.append("Lambda must be between 0 and 1")
        
        if config.tau < 0 or config.tau > 1:
            errors.append("Tau must be between 0 and 1")
        
        return errors


def load_config(config_path: str) -> GEPAConfig:
    """
    Convenience function to load configuration.
    
    Args:
        config_path: Path to .config file
        
    Returns:
        GEPAConfig object
    """
    return KconfigLoader.load_config(config_path)


def load_and_validate(config_path: str) -> GEPAConfig:
    """
    Load and validate configuration.
    
    Args:
        config_path: Path to .config file
        
    Returns:
        Validated GEPAConfig object
        
    Raises:
        ValueError: If validation fails
    """
    config = KconfigLoader.load_config(config_path)
    errors = KconfigLoader.validate_config(config)
    
    if errors:
        raise ValueError(
            "Configuration validation failed:\n" + 
            "\n".join(f"  - {e}" for e in errors)
        )
    
    return config
